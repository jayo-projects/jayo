/*
 * Copyright (c) 2025-present, pull-vert and Jayo contributors.
 * Use of this source code is governed by the Apache 2.0 license.
 *
 * Forked from Okio (https://github.com/square/okio), original copyright is below
 *
 * Copyright (C) 2013 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package jayo.internal

import jayo.*
import jayo.bytestring.ByteString
import jayo.bytestring.decodeHex
import jayo.crypto.JdkDigest
import jayo.internal.TestUtil.newThreadFactory
import org.assertj.core.api.Assertions.assertThatThrownBy
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import java.io.IOException
import java.util.*
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger
import kotlin.test.assertFailsWith
import kotlin.time.Duration.Companion.milliseconds

class PipeTest {
    private val executorService = Executors.newScheduledThreadPool(2, newThreadFactory())

    @AfterEach
    fun tearDown() {
        executorService.shutdown()
    }

    @Test
    fun test() {
        val pipe = Pipe(6)
        pipe.writer.writeFrom(Buffer().write("abc"), 3L)
        val reader = pipe.reader
        val readBuffer = Buffer()
        assertEquals(3L, reader.readAtMostTo(readBuffer, 6L))
        assertEquals("abc", readBuffer.readString())
        pipe.writer.close()
        assertEquals(-1L, reader.readAtMostTo(readBuffer, 6L))
        reader.close()
    }

    /**
     * A producer writes the first 16 MiB of bytes generated by `new Random(0)` to a writer, and a consumer consumes them. Both compute hashes of their data to confirm that they're as expected.
     */
    @Test
    fun largeDataset() {
        val pipe = Pipe(1000L) // An awkward size to force producer/consumer exchange.
        val totalBytes = 16L * 1024L * 1024L
        val expectedHash = "7c3b224bea749086babe079360cf29f98d88262d".decodeHex()

        // Write data to the writer.
        val writerHash = executorService.submit<ByteString> {
            val random = Random(0)
            val data = ByteArray(8192)
            val buffer = Buffer()
            var i = 0L
            while (i < totalBytes) {
                random.nextBytes(data)
                buffer.write(data)
                pipe.writer.writeFrom(Buffer().write(data), data.size.toLong())
                i += data.size.toLong()
            }
            pipe.writer.close()
            buffer.hash(JdkDigest.SHA_1)
        }

        // Read data from the reader.
        val readerHash = executorService.submit<ByteString> {
            val buffer = Buffer()
            while (pipe.reader.readAtMostTo(buffer, Long.MAX_VALUE) != -1L) {
            }
            pipe.reader.close()
            buffer.hash(JdkDigest.SHA_1)
        }
        assertEquals(expectedHash, writerHash.get())
        assertEquals(expectedHash, readerHash.get())
    }

    @Test
    fun writerTimeout() {
        val pipe = Pipe(3)
        pipe.writer.writeFrom(Buffer().write("abc"), 3L)
        val start = now()
        assertThatThrownBy {
            cancelScope(500.milliseconds) {
                pipe.writer.writeFrom(Buffer().write("def"), 3L)
            }
        }.isInstanceOf(JayoTimeoutException::class.java)
        assertElapsed(500.0, start)
        val readBuffer = Buffer()
        assertEquals(3L, pipe.reader.readAtMostTo(readBuffer, 6L))
        assertEquals("abc", readBuffer.readString())
    }

    @Test
    fun readerTimeout() {
        val pipe = Pipe(3L)
        val start = now()
        val readBuffer = Buffer()
        assertThatThrownBy {
            cancelScope(500.milliseconds) {
                pipe.reader.readAtMostTo(readBuffer, 6L)
            }
        }.isInstanceOf(JayoTimeoutException::class.java)
        assertElapsed(500.0, start)
        assertEquals(0, readBuffer.bytesAvailable())
    }

    /**
     * The writer is writing 12 bytes as fast as it can to a 3-byte buffer. The reader alternates sleeping 500 ms, then
     * reading 3 bytes. That should make for an approximate timeline like this:
     *
     * ```
     *    0: writer writes 'abc', blocks 0: reader sleeps until 500
     * 500: reader reads 'abc', sleeps until 1000
     * 500: writer writes 'def', blocks
     * 1000: reader reads 'def', sleeps until 1500
     * 1000: writer writes 'ghi', blocks
     * 1500: reader reads 'ghi', sleeps until 2000
     * 1500: writer writes 'jkl', returns
     * 2000: reader reads 'jkl', returns
     * ```
     *
     * Because the writer is writing to a buffer, it finishes before the reader does.
     */
    @Test
    fun writerBlocksOnSlowReader() {
        val pipe = Pipe(3L)
        val position = AtomicInteger()

        executorService.execute {
            val buffer = Buffer()
            Thread.sleep(500L)
            position.set(1)
            assertEquals(3, pipe.reader.readAtMostTo(buffer, Long.MAX_VALUE))
            assertEquals("abc", buffer.readString())
            Thread.sleep(500L)
            position.set(2)
            assertEquals(3, pipe.reader.readAtMostTo(buffer, Long.MAX_VALUE))
            assertEquals("def", buffer.readString())
            Thread.sleep(500L)
            position.set(3)
            assertEquals(3, pipe.reader.readAtMostTo(buffer, Long.MAX_VALUE))
            assertEquals("ghi", buffer.readString())
            Thread.sleep(500L)
            position.set(4)
            assertEquals(3, pipe.reader.readAtMostTo(buffer, Long.MAX_VALUE))
            assertEquals("jkl", buffer.readString())
        }

        pipe.writer.writeFrom(Buffer().write("abcdefghijkl"), 12)
        assertEquals(3, position.get())
    }

    @Test
    fun writerWriteFailsByClosedReader() {
        val pipe = Pipe(3L)
        executorService.schedule(
            {
                pipe.reader.close()
            },
            500,
            TimeUnit.MILLISECONDS,
        )
        val start = now()
        assertThatThrownBy {
            pipe.writer.writeFrom(Buffer().write("abcdef"), 6)
        }.isInstanceOf(JayoException::class.java)
            .hasMessage("reader is closed")

        assertElapsed(500.0, start)
    }

    @Test
    fun writerFlushDoesntWaitForReader() {
        val pipe = Pipe(100L)
        pipe.writer.writeFrom(Buffer().write("abc"), 3)
        pipe.writer.flush()
        val bufferedreader = pipe.reader.buffered()
        assertEquals("abc", bufferedreader.readString(3))
    }

    @Test
    fun writerFlushFailsIfReaderIsClosedBeforeAllDataIsRead() {
        val pipe = Pipe(100L)
        pipe.writer.writeFrom(Buffer().write("abc"), 3)
        pipe.reader.close()
        assertThatThrownBy {
            pipe.writer.flush()
        }.isInstanceOf(JayoException::class.java)
            .hasMessage("reader is closed")
    }

    @Test
    fun writerCloseFailsIfReaderIsClosedBeforeAllDataIsRead() {
        val pipe = Pipe(100L)
        pipe.writer.writeFrom(Buffer().write("abc"), 3)
        pipe.reader.close()
        assertThatThrownBy {
            pipe.writer.close()
        }.isInstanceOf(JayoException::class.java)
            .hasMessage("reader is closed")
    }

    @Test
    fun writerClose() {
        val pipe = Pipe(100L)
        pipe.writer.close()
        assertThatThrownBy {
            pipe.writer.writeFrom(Buffer().write("abc"), 3)
        }.isInstanceOf(IllegalStateException::class.java)
        assertThatThrownBy {
            pipe.writer.flush()
        }.isInstanceOf(IllegalStateException::class.java)
    }

    @Test
    fun writerMultipleClose() {
        val pipe = Pipe(100L)
        pipe.writer.close()
        pipe.writer.close()
    }

    @Test
    fun writerCloseDoesntWaitForreaderRead() {
        val pipe = Pipe(100L)
        pipe.writer.writeFrom(Buffer().write("abc"), 3)
        pipe.writer.close()
        val bufferedreader = pipe.reader.buffered()
        assertEquals("abc", bufferedreader.readString())
        assertTrue(bufferedreader.exhausted())
    }

    @Test
    fun readerClose() {
        val pipe = Pipe(100L)
        pipe.reader.close()
        assertThatThrownBy {
            pipe.reader.readAtMostTo(Buffer(), 3)
        }.isInstanceOf(IllegalStateException::class.java)
    }

    @Test
    fun readerMultipleClose() {
        val pipe = Pipe(100L)
        pipe.reader.close()
        pipe.reader.close()
    }

    @Test
    fun readerReadUnblockedByClosedwriter() {
        val pipe = Pipe(3L)
        executorService.schedule(
            {
                pipe.writer.close()
            },
            1000,
            TimeUnit.MILLISECONDS,
        )
        val start = now()
        val readBuffer = Buffer()
        assertEquals(-1, pipe.reader.readAtMostTo(readBuffer, Long.MAX_VALUE))
        assertEquals(0, readBuffer.bytesAvailable())
        assertElapsed(1000.0, start)
    }

    /**
     * The writer has 12 bytes to write. It alternates sleeping 500 ms, then writing 3 bytes. The reader is reading as
     * fast as it can. That should make for an approximate timeline like this:
     *
     * ```
     *    0: writer sleeps until 500
     *    0: reader blocks
     * 500: writer writes 'abc', sleeps until 1000
     * 500: reader reads 'abc'
     * 1000: writer writes 'def', sleeps until 1500
     * 1000: reader reads 'def'
     * 1500: writer writes 'ghi', sleeps until 2000
     * 1500: reader reads 'ghi'
     * 2000: writer writes 'jkl', returns
     * 2000: reader reads 'jkl', returns
     * ```
     */
    @Test
    fun readerBlocksOnSlowWriter() {
        val pipe = Pipe(100L)
        val position = AtomicInteger()

        executorService.execute {
            Thread.sleep(500L)
            position.set(1)
            pipe.writer.writeFrom(Buffer().write("abc"), 3)
            Thread.sleep(500L)
            position.set(2)
            pipe.writer.writeFrom(Buffer().write("def"), 3)
            Thread.sleep(500L)
            position.set(3)
            pipe.writer.writeFrom(Buffer().write("ghi"), 3)
            Thread.sleep(500L)
            position.set(4)
            pipe.writer.writeFrom(Buffer().write("jkl"), 3)
        }

        val readBuffer = Buffer()
        assertEquals(3, pipe.reader.readAtMostTo(readBuffer, Long.MAX_VALUE))
        assertEquals("abc", readBuffer.readString())
        assertEquals(1, position.get())

        assertEquals(3, pipe.reader.readAtMostTo(readBuffer, Long.MAX_VALUE))
        assertEquals("def", readBuffer.readString())
        assertEquals(2, position.get())

        assertEquals(3, pipe.reader.readAtMostTo(readBuffer, Long.MAX_VALUE))
        assertEquals("ghi", readBuffer.readString())
        assertEquals(3, position.get())

        assertEquals(3, pipe.reader.readAtMostTo(readBuffer, Long.MAX_VALUE))
        assertEquals("jkl", readBuffer.readString())
        assertEquals(4, position.get())
    }

    /** Returns the nanotime in milliseconds as a double for measuring timeouts. */
    private fun now(): Double {
        return System.nanoTime() / 1000000.0
    }

    /**
     * Fails the test unless the time from start until now is duration, accepting differences in
     * -50..+450 milliseconds.
     */
    private fun assertElapsed(duration: Double, start: Double) {
        assertEquals(duration, now() - start - 200.0, 250.0)
    }

    @Test
    fun pipe() {
        val pipe = Pipe(6)
        pipe.writer.writeFrom(Buffer().write("abc"), 3L)

        val readBuffer = Buffer()
        assertEquals(3L, pipe.reader.readAtMostTo(readBuffer, 6L))
        assertEquals("abc", readBuffer.readString())

        pipe.writer.close()
        assertEquals(-1L, pipe.reader.readAtMostTo(readBuffer, 6L))

        pipe.reader.close()
    }

    @Test
    fun fold() {
        val pipe = Pipe(128)

        val pipewriter = pipe.writer.buffered()
        pipewriter.write("hello")
        pipewriter.emit()

        val pipereader = pipe.reader.buffered()
        assertEquals("hello", pipereader.readString(5))

        val foldedwriterBuffer = Buffer()
        var foldedwriterClosed = false
        val foldedwriter = object : RawWriter {
            override fun writeFrom(source: Buffer, byteCount: Long) {
                foldedwriterBuffer.writeFrom(source, byteCount)
            }

            override fun flush() {
                foldedwriterBuffer.flush()
            }

            override fun close() {
                foldedwriterClosed = true
                foldedwriterBuffer.close()
            }
        }
        pipe.fold(foldedwriter)

        pipewriter.write("world")
        pipewriter.emit()
        assertEquals("world", foldedwriterBuffer.readString(5))

        assertFailsWith<IllegalStateException> {
            pipereader.readString()
        }

        pipewriter.close()
        assertTrue(foldedwriterClosed)
    }

    @Test
    fun foldWritesPipeContentsToWriter() {
        val pipe = Pipe(128)

        val pipewriter = pipe.writer.buffered()
        pipewriter.write("hello")
        pipewriter.emit()

        val foldwriter = Buffer()
        pipe.fold(foldwriter)

        assertEquals("hello", foldwriter.readString(5))
    }

    @Test
    fun foldUnblocksBlockedWrite() {
        val pipe = Pipe(4)
        val foldwriter = Buffer()

        val latch = CountDownLatch(1)
        executorService.schedule({
            pipe.fold(foldwriter)
            latch.countDown()
        }, 500, TimeUnit.MILLISECONDS)

        val writer = pipe.writer.buffered()
        writer.write("abcdefgh") // Blocks writing 8 bytes to a 4 byte pipe.
        writer.close()

        latch.await()
        assertEquals("abcdefgh", foldwriter.readString())
    }

    @Test
    fun accessReaderAfterFold() {
        val pipe = Pipe(100L)
        pipe.fold(Buffer())
        assertFailsWith<IllegalStateException> {
            pipe.reader.readAtMostTo(Buffer(), 1L)
        }
    }

    @Test
    fun closeWhileFolding() {
        val pipe = Pipe(100L)
        val writing = CountDownLatch(1)
        val closed = CountDownLatch(1)
        val writerBuffer = Buffer()
        val writerClosed = AtomicBoolean()
        val data = byteArrayOf(1, 2, 3, 4, 5, 6, 7, 8)
        pipe.writer.writeFrom(Buffer().write(data), data.size.toLong())
        val foldResult = executorService.submit {
            val writer = object : RawWriter {
                override fun writeFrom(reader: Buffer, byteCount: Long) {
                    writing.countDown()
                    closed.await()
                    writerBuffer.writeFrom(reader, byteCount)
                }

                override fun flush() {
                    writerBuffer.flush()
                }

                override fun close() {
                    writerBuffer.close()
                    writerClosed.set(true)
                }
            }
            pipe.fold(writer)
        }
        writing.await()
        pipe.writer.close()
        closed.countDown()
        foldResult.get()

        assertTrue(writerClosed.get())
        assertArrayEquals(data, writerBuffer.readByteArray())
    }

    @Test
    fun foldingTwiceThrows() {
        val pipe = Pipe(128)
        pipe.fold(Buffer())
        assertFailsWith<IllegalStateException> {
            pipe.fold(Buffer())
        }
    }

    @Test
    fun writerWriteThrowsJayoExceptionUnblockBlockedWriter() {
        val pipe = Pipe(4)

        val foldFuture = executorService.schedule({
            val foldFailure = assertFailsWith<IOException> {
                pipe.fold(
                    object : RawWriter {
                        override fun writeFrom(reader: Buffer, byteCount: Long) {
                            throw IOException("boom")
                        }

                        override fun flush() {
                            // nop
                        }

                        override fun close() {
                            // nop
                        }
                    },
                )
            }
            assertEquals("boom", foldFailure.message)
        }, 500, TimeUnit.MILLISECONDS)

        val writeFailure = assertFailsWith<JayoException> {
            val pipewriter = pipe.writer.buffered()
            pipewriter.write("abcdefghij")
            pipewriter.emit() // Block writing 10 bytes to a 4 byte pipe.
        }
        assertEquals("reader is closed", writeFailure.message)

        foldFuture.get() // Confirm no unexpected exceptions.
    }

    /**
     * Flushing the pipe wasn't causing the writer to be flushed when it was later folded. This was
     * causing problems because the folded data was stalled.
     */
    @Test
    fun foldFlushesWhenThereIsFoldedData() {
        val pipe = Pipe(128)
        val pipewriter = pipe.writer.buffered()
        pipewriter.write("hello")
        pipewriter.emit()

        val ultimatewriter = Buffer()
        val unnecessaryWrapper = (ultimatewriter as Writer).buffered()

        pipe.fold(unnecessaryWrapper)

        // Data should not have been flushed through the wrapper to the ultimate writer.
        assertEquals("hello", ultimatewriter.readString())
    }

    @Test
    fun foldDoesNotFlushWhenThereIsNoFoldedData() {
        val pipe = Pipe(128)

        val ultimatewriter = Buffer()
        val unnecessaryWrapper = (ultimatewriter as Writer).buffered()
        unnecessaryWrapper.write("hello")

        pipe.fold(unnecessaryWrapper)

        // Data should not have been flushed through the wrapper to the ultimate writer.
        assertEquals("", ultimatewriter.readString())
    }

    @Test
    fun foldingClosesUnderlyingwriterWhenPipewriterIsClose() {
        val pipe = Pipe(128)

        val pipewriter = pipe.writer.buffered()
        pipewriter.write("world")
        pipewriter.close()

        val foldedwriterBuffer = Buffer()
        var foldedwriterClosed = false
        val foldedwriter = object : RawWriter {
            override fun writeFrom(source: Buffer, byteCount: Long) {
                foldedwriterBuffer.writeFrom(source, byteCount)
            }

            override fun flush() {
                foldedwriterBuffer.flush()
            }

            override fun close() {
                foldedwriterClosed = true
                foldedwriterBuffer.close()
            }
        }

        pipe.fold(foldedwriter)
        assertEquals("world", foldedwriterBuffer.readString(5))
        assertTrue(foldedwriterClosed)
    }

    @Test
    fun cancelPreventswriterWrite() {
        val pipe = Pipe(8)
        pipe.cancel()

        val pipewriter = pipe.writer.buffered()
        pipewriter.write("hello world")

        assertThatThrownBy {
            pipewriter.emit()
        }.isInstanceOf(JayoException::class.java)
            .hasMessage("canceled")
    }

    @Test
    fun cancelPreventswriterFlush() {
        val pipe = Pipe(8)
        pipe.cancel()

        assertThatThrownBy {
            pipe.writer.flush()
        }.isInstanceOf(JayoException::class.java)
            .hasMessage("canceled")
    }

    @Test
    fun writerCloseAfterCancelDoesNotThrow() {
        val pipe = Pipe(8)
        pipe.cancel()
        pipe.writer.close()
    }

    @Test
    fun cancelInterruptswriterWrite() {
        val pipe = Pipe(8)

        executorService.schedule({
            pipe.cancel()
        }, smallerTimeoutNanos, TimeUnit.NANOSECONDS)

        val pipewriter = pipe.writer.buffered()
        pipewriter.write("hello world")

        assertDuration(smallerTimeoutNanos) {
            assertThatThrownBy {
                pipewriter.emit()
            }.isInstanceOf(JayoException::class.java)
                .hasMessage("canceled")
        }
    }

    @Test
    fun cancelPreventsreaderRead() {
        val pipe = Pipe(8)
        pipe.cancel()

        val pipereader = pipe.reader.buffered()

        assertThatThrownBy {
            pipereader.require(1)
        }.isInstanceOf(JayoException::class.java)
            .hasMessage("canceled")
    }

    @Test
    fun readerCloseAfterCancelDoesNotThrow() {
        val pipe = Pipe(8)
        pipe.cancel()
        pipe.reader.close()
    }

    @Test
    fun cancelInterruptsreaderRead() {
        val pipe = Pipe(8)

        executorService.schedule({
            pipe.cancel()
        }, smallerTimeoutNanos, TimeUnit.NANOSECONDS)

        val pipereader = pipe.reader.buffered()

        assertDuration(smallerTimeoutNanos) {
            assertThatThrownBy {
                pipereader.require(1)
            }.isInstanceOf(JayoException::class.java)
                .hasMessage("canceled")
        }
    }

    @Test
    fun cancelPreventswriterFold() {
        val pipe = Pipe(8)
        pipe.cancel()

        var foldedWriterClosed = false
        val foldedwriterBuffer = Buffer()
        val foldedwriter = object : RawWriter {
            override fun writeFrom(source: Buffer, byteCount: Long) {
                foldedwriterBuffer.writeFrom(source, byteCount)
            }

            override fun flush() {
                foldedwriterBuffer.flush()
            }

            override fun close() {
                foldedWriterClosed = true
                foldedwriterBuffer.close()
            }
        }

        assertThatThrownBy {
            pipe.fold(foldedwriter)
        }.isInstanceOf(JayoException::class.java)
            .hasMessage("canceled")

        // But the fold is still performed so close() closes everything.
        assertFalse(foldedWriterClosed)
        pipe.writer.close()
        assertTrue(foldedWriterClosed)
    }

    @Test
    fun cancelInterruptswriterFold() {
        val pipe = Pipe(128)
        val pipewriter = pipe.writer.buffered()
        pipewriter.write("hello")
        pipewriter.emit()

        var foldedWriterClosed = false
        val foldedwriterBuffer = Buffer()
        val foldedwriter = object : RawWriter {
            override fun writeFrom(source: Buffer, byteCount: Long) {
                assertEquals("hello", source.readString(byteCount))

                // Write bytes to the original pipe so the pipe write doesn't complete!
                pipewriter.write("more bytes")
                pipewriter.emit()

                // Cancel while the pipe is writing.
                pipe.cancel()
            }

            override fun flush() {
                foldedwriterBuffer.flush()
            }

            override fun close() {
                foldedWriterClosed = true
                foldedwriterBuffer.close()
            }
        }

        assertThatThrownBy {
            pipe.fold(foldedwriter)
        }.isInstanceOf(JayoException::class.java)
            .hasMessage("canceled")

        // But the fold is still performed so close() closes everything.
        assertFalse(foldedWriterClosed)
        pipe.writer.close()
        assertTrue(foldedWriterClosed)
    }

    private fun assertDuration(expected: Long, block: () -> Unit) {
        val start = System.currentTimeMillis()
        block()
        val elapsed = TimeUnit.MILLISECONDS.toNanos(System.currentTimeMillis() - start)

        assertEquals(
            expected.toDouble(),
            elapsed.toDouble(),
            TimeUnit.MILLISECONDS.toNanos(200).toDouble(),
        )
    }

    companion object {
        val smallerTimeoutNanos = TimeUnit.MILLISECONDS.toNanos(500L)
    }
}
